TODO  1.word编写
      2.考虑执行顺序+考虑相似性的选取
      3.准备问老师什么时候结课

TODO 介绍：
1.查看文献,限制性锦标赛选择算子进行了实现,嵌入到原有GA中,为了适配，对原有范式做了适当修改
2.后来时间比较充裕,顺便把确定性拥挤算子实现了，其两者都利用的是拥挤思想，其逻辑和思路大致相同，实现的话,代码都存在共用的部分,难度不大
3.检验限制锦标赛选择算子的性能 (和文献做再一次的确认)

TODO word：
先用伪代码简单描述一下自己的实现步骤和逻辑：
1.伪代码的解释
利用的是拥挤思想
拥挤算法是是如何保持种群多样性。其基本思想是当物种繁衍到一定规模，生存空间变得拥挤，新产生的个体必须与其他个体竞争，才可能出现在下一代种群中。
具有适应度值较高的新个体去替换掉它附近的适应值较低的老个体，新个体始终替换与其接近的个体，从而维持种群的多样性。


确定性拥挤算子:
      1.有放回的随机选取两个父代个体p1 p2
      2.父代交叉、变异，产生新个体：c1 c2
      3.替换阶段(采用拥挤思想来决定下一代)：
             3.1 如果[d(p1,c1)+d(p2,c2)]<=[d(p1,c2)+d(p2,c1)]
                          如果f(c1)>f(p1),则用c1替换p1,否则保留p1;
                          如果f(c2)>f(p2),则用c2替换p2,否则保留p2;
              3.2 否则
                           如果f(c1)>f(p2),则用c1替换p2,否则保留p2;
                           如果f(c2)>f(p1),则用c2替换p1,否则保留p1;



两种拥挤算法的主要区别在于新个体与老个体的竞争方式不同。根据这一分类，拥挤算法可以分为两种类型，即新个体与其父母竞争和新个体与随机的老个体竞争。

1.新个体 vs 父母竞争：确定性拥挤算法
2.新个体 vs 随机老个体：限制锦标赛选择算法

限制锦标赛策略是确定性拥挤算法的泛化

      3.为个体c1从当前种群中随机选取w个个体  w是窗口大小,即N元锦标赛（原有范式） windowing mechanism 窗口机制,这样就为每个个体产生了C个替补候选个体
      4.设d1分别为w个个体中与c1距离最近的两个个体
               多小生境拥挤算法的搜索能力在拥挤算法中是最强的，这要归功于多个老个体竞争替换策略
               前者的效果与基于个体距离的限制交配策略类似

TODO 执行顺序和相似性的选取：（多样性 + 适应值）
选择 -- 交叉 -- 变异 -- 校验
选择 -- 交叉 -- 小生境 -- 校验

TODO 性能对比：
前提：迭代次数：370代 交叉变异概率：0.6/0.8 种群大小：100
RTS：窗口大小10 小生境数4

结果：GA和RTS维持多样性的性能都很优秀，且RTS略优于GA. RTS为GA提供大量的时间来搜索解
    解释一下，为什么GA性能都这么好,出现这种情况的原因在于：校验（长度、类型、属性） 本质上都是变异

但这就导致一个问题：
执行小生境后，再执行修补算子是否会影响多样性呢？
            似的个体指的是adi的相似，
            修补修补的是长度、类型、属性，
            两个方向不一样,是否会有很多无效行为。后期查看相关文献,考虑其相关性


文献：
比较：calculating probability distributions 1.限制适应度值
     various niche takeover times.         2.接管时间

how a persistently dominant individual begins to take over a population under RTS.
a proportion equal to 1/
take over one half of the population(w + 1)

log(N/w + 1)
 We would also like for RTS to delay for an inordinately long period of time an individual trying to take over a large part, say one half, of the search space.
 RTS为GA提供大量的时间来搜索解
